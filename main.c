#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          addon,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define THRESHOLD 50

//distances in subroutines
#define CAN_DIST 22.0
#define RING_DIST 14.0

/*****************************
*********Subroutines**********
*****************************/

int halt()
{
	motor[left] = 0;
	motor[right] = 0;
	motor[addon] = 0;
	return 0;
}

bool line()
{
	return SensorValue[light] < THRESHOLD;
}

int getring()
{
 	motor[addon] = -30;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int dropring()
{
	motor[addon] = 30;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int deploy_fork()
{
	motor[addon] = 30;
	wait10Msec(15);
	motor[addon] = 0;
	return 0;
}

int open_claw()
{
	motor[addon] = 100;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int close_claw()
{
	motor[addon] = -100;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int pushblocks()
{
	return 1;
}

int turn_left(float numDegrees)
{
	motor[right] = 20;
	motor[left] = 0;
	wait10Msec((240.0 / 90.0) * numDegrees);
	motor[right] = 0;
	return 0;
}

int turn_right(float numDegrees)
{
	motor[left] = 20;
	motor[right] = 0;
	wait10Msec((240.0 / 90.0) * numDegrees);
	motor[left] = 0;
	return 0;
}

int forward(float num) // Move forward one foot
{
	motor[left] = 20;
	motor[right] = 20;
	wait10Msec(320.0 * num);
	motor[left] = 0;
	motor[right] = 0;
	return 0;
}

int backward(float num)
{
	motor[left] = -20;
	motor[right] = -20;
	wait10Msec(320.0 * num);
	motor[left] = 0;
	motor[right] = 0;
	return 0;
}

int waitpress()
{
	while(nNxtButtonPressed != 3) wait10Msec(1);
	wait10Msec(100);
	return 1;
}

int print(char * text)
{
	eraseDisplay();
	nxtDisplayCenteredTextLine(4, text);
  return 0;
}

/*****************************
********Main Routines*********
*****************************/

int linefollow()
{
	bool go = true;

	//move forwards until we get to the edge of the home box
	motor[left] = 100;
	motor[right] = 100;
	while(!go)
	{
		go = true;
		for(int n=0; n<100; n++)
		{
			wait10Msec(1);
			if(!line()) go = false;
		}
	}

	//now follow the line, keeping it to our left
	while(nNxtButtonPressed != 3) //stop on press of orange button
	{
		if(line()) //on the line, veer right
		{
			motor[left] = 50;
			motor[right] = 0;
		}
		else //not on the line, veer left
		{
			motor[left] = 0;
			motor[right] = 50;
		}
		wait10Msec(1);
	}
	halt();
	return 0;
}

int ring()
{
	forward(RING_DIST/12.0);
	getring();
	backward(RING_DIST/12.0);
	dropring();
	return 1;
}

int push()
{
	//TODO
	return 1;
}

int knock()
{
	//TODO
	return 1;
}

int can()
{
	waitpress();
	close_claw();
	forward(CAN_DIST/12.0);
	open_claw();
	backward(CAN_DIST/12.0);
	return 1;
}

/*
Plan of Attack
--------------
1. Place can on target	DONE
2. Get ring							NEEDS TESTING
3. Push blocks					TODO
4. Knock over blocks		TODO
5. Follow the line			DONE
*/


task main()
{
	wait10Msec(50);
	print("Ready 2 Roll");
	waitpress();

	//place can on target
	print("Placing Can...");
	can();
	waitpress();

	//get ring
	print("Getting Ring...");
	ring();
	waitpress();

	//push blocks
	print("Pushing Blocks...");
	push();
	waitpress();

	//knock over blocks
	print("Knocking Blocks...");
	knock();
	waitpress();

	//follow the line
	print("Following line...");
	linefollow();

	return;
}
