#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          addon,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define THRESHOLD 45

//distances in subroutines
#define CAN_DIST 22.0
#define RING_DIST 15.0
#define PUSH_DIST 25.0
#define KNOCK_DIST 27.0
#define SHOVE_DIST 6.0
#define LINE_SPEED 80.0

/*****************************
*********Subroutines**********
*****************************/

int halt()
{
	motor[left] = 0;
	motor[right] = 0;
	motor[addon] = 0;
	return 0;
}

bool line()
{
	return SensorValue[light] < THRESHOLD;
}

int getring()
{
 	motor[addon] = -30;
	wait10Msec(90);
	motor[addon] = 0;
	return 0;
}

int dropring()
{
	motor[addon] = 30;
	wait10Msec(90);
	motor[addon] = 0;
	return 0;
}

int deploy_fork()
{
	motor[addon] = 30;
	wait10Msec(15);
	motor[addon] = 0;
	return 0;
}

int open_claw()
{
	motor[addon] = 100;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int close_claw()
{
	motor[addon] = -100;
	wait10Msec(100);
	motor[addon] = 0;
	return 0;
}

int turn_left(float numDegrees)
{
	motor[right] = 20;
	motor[left] = -20;
	wait10Msec((120.0 / 90.0) * numDegrees);
	motor[right] = 0;
	motor[left] = 0;
	return 0;
}

int turn_right(float numDegrees)
{
	motor[left] = 20;
	motor[right] = -20;
	wait10Msec((120.0 / 90.0) * numDegrees);
	motor[left] = 0;
	motor[right] = 0;
	return 0;
}

int forward(float num) // Move forward one foot
{
	motor[left] = 20;
	motor[right] = 20;
	wait10Msec(320.0 * num);
	motor[left] = 0;
	motor[right] = 0;
	return 0;
}

int backward(float num)
{
	motor[left] = -20;
	motor[right] = -20;
	wait10Msec(320.0 * num);
	motor[left] = 0;
	motor[right] = 0;
	return 0;
}

int waitpress()
{
	while(nNxtButtonPressed != 3) wait10Msec(1);
	wait10Msec(20);
	return 1;
}

int print(char * text)
{
	eraseDisplay();
	nxtDisplayCenteredTextLine(4, text);
  return 0;
}

/*****************************
********Main Routines*********
*****************************/

int linefollow()
{
	//now follow the line, keeping it to our left
	while(nNxtButtonPressed != 3) //stop on press of orange button
	{
		if(line()) //on the line, veer right
		{
			motor[left] = LINE_SPEED;
			motor[right] = -10;
		}
		else //not on the line, veer left
		{
			motor[left] = -10;
			motor[right] = LINE_SPEED;
		}
		wait1Msec(1);
	}
	halt();
	return 0;
}

int ring()
{
	forward(RING_DIST/12.0);
	getring();
	backward(RING_DIST/12.0);
	turn_left(180);
	dropring();
	backward(2/12.0);
	return 1;
}

int push()
{
	forward(PUSH_DIST/12.0);
	backward(PUSH_DIST/12.0);
	return 1;
}

int knock()
{
	forward(KNOCK_DIST/12.0);
	getring();
	forward(SHOVE_DIST/12.0);
	backward(SHOVE_DIST/12.0);
	forward(SHOVE_DIST/12.0);
	backward(SHOVE_DIST/12.0);
	dropring();
	backward(KNOCK_DIST/12.0);
	return 1;
}

int can()
{
	close_claw();
	forward(CAN_DIST/12.0);
	open_claw();
	backward(CAN_DIST/12.0);
	return 1;
}

/*
Plan of Attack
--------------
1. Place can on target	DONE
2. Get ring							DONE
3. Knock over blocks		DONE
4. Push blocks					DONE
5. Follow the line			DONE
*/


task main()
{
	wait10Msec(50);
	print("Ready 2 Roll");
	waitpress();

	//place can on target
	print("Placing Can...");
	can();
	waitpress();

	//get ring
	print("Getting Ring...");
	ring();
	waitpress();

	//knock over blocks
	print("Knocking Blocks...");
	knock();
	waitpress();

	//push blocks
	print("Pushing Blocks...");
	push();
	waitpress();

	//follow the line
	print("Following line...");
	linefollow();

	return;
}
